## State machine и события (спецификация)

Документ фиксирует состояние приложения, допустимые события, переходы, побочные эффекты и правила UI. Псевдокод и термины — на русском.

---

### 1) Термины

* **Control-сервер** — сервер(а), указанные в конфигурации приложения, с которыми выполняются: проверка доступности, авторизация, обновление списков серверов/маршрутов. В MVP предполагается один Control-сервер (поддержка нескольких может быть добавлена позже).
* **Прокси-сервер** — конечная точка подключения (из списка, полученного с Control-сервера).
* **Профиль маршрутизации** — вариант маршрутизации (из списка, полученного с Control-сервера). Содержит наборы:

  * DirectRoutes: подсети, которые должны идти напрямую (в обход туннеля)
  * TunnelRoutes: подсети/правила, которые должны идти через туннель (может быть «всё кроме DirectRoutes»)
* **Core** — xray или sing-box (пока выбор не сделан).
* **Маршруты служебные** — маршруты до Control-сервера(ов) и до выбранного прокси-сервера(ов) через шлюз по умолчанию.

### 2) Глобальные инварианты

1. Приложение не должно оставлять мусорные маршруты после "Отключения" или "Выхода" (best-effort cleanup).
2. В состоянии Connected должен быть запущен процесс Core.
3. В состоянии ReadyDisconnected процесс Core не должен быть запущен.
4. Все маршруты, добавленные приложением, должны быть **маркированы/учтены** в внутреннем реестре RoutesRegistry (для корректного удаления).
5. Все процессы, запущенные приложением, должны быть учтены в ProcessRegistry (PID/handle, время старта, статус).

### 3) Состояния (State)

Перечень:

* **AppStarting** — старт приложения, чтение конфигурации, первичная проверка сред.
* **PreflightCheck** — проверка доступности Control-серверов.
* **WaitingLogin** — ожидание ввода логина/пароля.
* **AuthInProgress** — выполняется запрос авторизации.
* **SyncInProgress** — обновление списков прокси-серверов и маршрутов.
* **PreparingEnvironment** — определение шлюза, добавление служебных маршрутов.
* **ReadyDisconnected** — готово к подключению, но туннель не поднят.
* **Connecting** — выполняется последовательность подключения (маршруты/direct, конфиг core, запуск процессов).
* **Connected** — подключено.
* **Disconnecting** — выполняется последовательность отключения (stop tun, stop core, remove routes).
* **Error** — ошибка, требующая внимания пользователя (с возможностью "Повторить" / "Выйти" / "Сбросить").
* **Exiting** — завершение приложения (cleanup).

Подтипы Error (ErrorKind):

* NetworkUnavailable
* AuthFailed
* SyncFailed
* RoutingFailed
* ProcessFailed
* ConfigFailed
* Unknown

### 4) События (Event)

События UI:

* **UI_Запуск**
* **UI_ВводЛогинаПароля(логин, пароль)**
* **UI_НажатаВойти**
* **UI_ВыбранСервер(serverId)**
* **UI_ВыбранПрофильМаршрутов(profileId)**
* **UI_НажатаПодключиться**
* **UI_НажатаОтключиться**
* **UI_ОткрытьНастройки**
* **UI_ЗакрытьОкно** (крестик)
* **UI_ВыходИзМеню**

События Tray:

* **TRAY_ПоказатьОкно**
* **TRAY_СкрытьОкно**
* **TRAY_Подключиться**
* **TRAY_Отключиться**
* **TRAY_Выход**

Системные/внутренние:

* **SYS_РезультатPreflight(успех|ошибка)**
* **SYS_РезультатAuth(успех|ошибка)**
* **SYS_РезультатSync(успех|ошибка)**
* **SYS_РезультатPrepareEnv(успех|ошибка)**
* **SYS_ПроцессЗавершён(processName, exitCode, reason)**
* **SYS_Таймаут(операция)**

### 5) Контекст приложения (AppContext)

Ключевые поля:

* config: Config
* authToken: string | пусто
* serversList: []Server
* routesProfiles: []RouteProfile
* selectedServerId: string | пусто
* selectedProfileId: string | пусто
* defaultGateway: GatewayInfo | пусто
* routesRegistry: RoutesRegistry
* processRegistry: ProcessRegistry
* lastError: ErrorInfo | пусто
* ui: UIState (для включения/выключения кнопок и отображения статусов)

### 6) Таблица переходов (высокоуровневая)

1. AppStarting

* На UI_Запуск → PreflightCheck (запустить Preflight)

2. PreflightCheck

* На SYS_РезультатPreflight(успех) → WaitingLogin
* На SYS_РезультатPreflight(ошибка) → Error(NetworkUnavailable)

3. WaitingLogin

* На UI_НажатаВойти (если логин/пароль заполнены) → AuthInProgress
* На UI_ВыходИзМеню / TRAY_Выход → Exiting

4. AuthInProgress

* На SYS_РезультатAuth(успех) → SyncInProgress
* На SYS_РезультатAuth(ошибка) → Error(AuthFailed)

5. SyncInProgress

* На SYS_РезультатSync(успех) → PreparingEnvironment
* На SYS_РезультатSync(ошибка) → Error(SyncFailed)

6. PreparingEnvironment

* На SYS_РезультатPrepareEnv(успех) → ReadyDisconnected
* На SYS_РезультатPrepareEnv(ошибка) → Error(RoutingFailed)

7. ReadyDisconnected

* На UI_НажатаПодключиться / TRAY_Подключиться (если выбран serverId и profileId) → Connecting
* На UI_ОткрытьНастройки → (остаться в ReadyDisconnected, открыть окно настроек)
* На UI_ЗакрытьОкно → (остаться, просто скрыть окно)
* На UI_ВыходИзМеню / TRAY_Выход → Exiting

8. Connecting

* На успешное завершение сценария подключения → Connected
* На ошибку на любом шаге → Error(ProcessFailed/ConfigFailed/RoutingFailed)
* На UI_НажатаОтключиться → (игнор/поставить флаг отмены, решение описано ниже)

9. Connected

* На UI_НажатаОтключиться / TRAY_Отключиться → Disconnecting
* На SYS_ПроцессЗавершён(Core) → Error(ProcessFailed) с автопереходом в Disconnecting(best-effort)
* На UI_ЗакрытьОкно → (остаться Connected, скрыть окно)
* На UI_ВыходИзМеню / TRAY_Выход → Exiting (с обязательным Disconnecting внутри)

10. Disconnecting

* На успешное завершение сценария отключения → ReadyDisconnected
* На ошибки удаления маршрутов/остановки процессов → ReadyDisconnected (best-effort) + запись lastError (не блокирующая)

11. Error

* На UI_НажатаВойти (если ошибка авторизации) → AuthInProgress (повтор)
* На UI_НажатаПодключиться (если ошибка подключения) → Connecting (повтор) при выполненных предусловиях
* На TRAY_Выход / UI_ВыходИзМеню → Exiting
* На TRAY_ПоказатьОкно → показать окно

12. Exiting

* Всегда: выполнить cleanup (остановить процессы, удалить маршруты) → завершить приложение

### 7) Правила UI по состояниям

WaitingLogin:

* Показать окно логина.
* Включены: поля логина/пароля, кнопка «Войти».
* Выключены: все элементы подключения.

ReadyDisconnected:

* Показать главное окно.
* Включены: выбор сервера, выбор профиля, кнопка «Подключиться», «Настройки».
* Выключены: «Отключиться».

Connecting:

* Блокировать изменения выбора сервера/профиля.
* «Подключиться» выключена.
* «Отключиться» по умолчанию выключена (или выполняет "отмену" — если будет внедрено).

Connected:

* Включены: «Отключиться», «Настройки» (по желанию: либо разрешить, либо запретить на время подключения).
* Выключены: «Подключиться», выбор сервера/профиля.
* Показать статус "Подключено".

Disconnecting:

* Все элементы управления подключением выключены.

Error:

* Показать окно/диалог ошибки.
* Показать диалог всегда **модальным** (блокирующим до выбора действия).
* Предложить доступные действия: "Повторить", "Открыть главное окно", "Выйти" (набор зависит от ErrorKind, см. раздел 10.6).

* Вход в состояние PreflightCheck происходит из AppStarting на событие UI_Запуск.
* Приложение выполняет HTTP(S)-запрос к эндпоинту `/health` Control-сервера.
* В MVP используется **один** Control-сервер, базовый URL берётся из `Config.control_server_url`.
* Успешным результатом проверки считается ответ с кодом 200 и телом `"OK"` (строка). Любой другой код ответа или содержимое тела считается ошибкой.
* При неуспехе (ошибка сети, таймаут, некорректный код/тело ответа) выполняется до **трёх** повторных попыток с задержкой **2 секунды** между ними.
* Если все три попытки завершились неуспехом, генерируется SYS_РезультатPreflight(ошибка), выполняется переход в Error(NetworkUnavailable), в UI показывается модальный диалог "Не удалось подключиться к управляющему серверу" с кнопкой "Повторить" (запускает Preflight заново) и возможностью выхода.
* При успешной проверке генерируется SYS_РезультатPreflight(успех) и выполняется переход в WaitingLogin.

```text
ФУНКЦИЯ ОбработатьСобытие(event):
  ВЫБРАТЬ state

    КОГДА AppStarting:
      ЕСЛИ event == UI_Запуск:
        ПЕРЕЙТИ В PreflightCheck
        ЗАПУСТИТЬ Preflight()

    КОГДА PreflightCheck:
      ЕСЛИ event == SYS_РезультатPreflight(успех):
        ПЕРЕЙТИ В WaitingLogin
        UI.ПоказатьОкноЛогина()
      ИНАЧЕ ЕСЛИ event == SYS_РезультатPreflight(ошибка):
        ПЕРЕЙТИ В Error(NetworkUnavailable)
        UI.ПоказатьОшибку("Нет связи с серверами")

    КОГДА WaitingLogin:
      ЕСЛИ event == UI_НажатаВойти И UI.ЛогинПарольЗаполнены():
        ПЕРЕЙТИ В AuthInProgress
        ЗАПУСТИТЬ Авторизация(логин, пароль)
      ЕСЛИ event == UI_ВыходИзМеню ИЛИ event == TRAY_Выход:
        ПЕРЕЙТИ В Exiting
        ЗАПУСТИТЬ CleanupИВыход()

    КОГДА AuthInProgress:
      ЕСЛИ event == SYS_РезультатAuth(успех, token):
        ctx.authToken = token
        ПЕРЕЙТИ В SyncInProgress
        ЗАПУСТИТЬ СинхронизацияСписков()
      ИНАЧЕ ЕСЛИ event == SYS_РезультатAuth(ошибка):
        ПЕРЕЙТИ В Error(AuthFailed)
        UI.ПоказатьОшибку("Неверный логин/пароль или доступ запрещён")

    КОГДА SyncInProgress:
      ЕСЛИ event == SYS_РезультатSync(успех, serversList, routesProfiles):
        ctx.serversList = serversList
        ctx.routesProfiles = routesProfiles
        ПЕРЕЙТИ В PreparingEnvironment
        ЗАПУСТИТЬ ПодготовкаОкружения()
      ИНАЧЕ ЕСЛИ event == SYS_РезультатSync(ошибка):
        ПЕРЕЙТИ В Error(SyncFailed)
        UI.ПоказатьОшибку("Не удалось обновить списки")

    КОГДА PreparingEnvironment:
      ЕСЛИ event == SYS_РезультатPrepareEnv(успех, defaultGateway):
        ctx.defaultGateway = defaultGateway
        ПЕРЕЙТИ В ReadyDisconnected
        UI.ПоказатьГлавноеОкно()
        UI.ОбновитьСписки(serversList, routesProfiles)
      ИНАЧЕ ЕСЛИ event == SYS_РезультатPrepareEnv(ошибка):
        ПЕРЕЙТИ В Error(RoutingFailed)
        UI.ПоказатьОшибку("Не удалось подготовить маршрутизацию")

    КОГДА ReadyDisconnected:
      ЕСЛИ event == UI_ЗакрытьОкно:
        UI.СкрытьГлавноеОкно()
      ЕСЛИ event == TRAY_ПоказатьОкно:
        UI.ПоказатьГлавноеОкно()
      ЕСЛИ event == UI_НажатаПодключиться ИЛИ event == TRAY_Подключиться:
        ЕСЛИ ctx.selectedServerId пусто ИЛИ ctx.selectedProfileId пусто:
          UI.ПоказатьОшибку("Выберите сервер и профиль маршрутов")
        ИНАЧЕ:
          ПЕРЕЙТИ В Connecting
          ЗАПУСТИТЬ СценарийПодключения()
      ЕСЛИ event == UI_ВыходИзМеню ИЛИ event == TRAY_Выход:
        ПЕРЕЙТИ В Exiting
        ЗАПУСТИТЬ CleanupИВыход()

    КОГДА Connecting:
      ЕСЛИ event == SYS_ПроцессЗавершён(Core, ...):
        // неожиданный выход во время подключения
        ПЕРЕЙТИ В Error(ProcessFailed)
        UI.ПоказатьОшибку("Процесс завершился во время подключения")

    КОГДА Connected:
      ЕСЛИ event == UI_ЗакрытьОкно:
        UI.СкрытьГлавноеОкно()
      ЕСЛИ event == TRAY_ПоказатьОкно:
        UI.ПоказатьГлавноеОкно()
      ЕСЛИ event == UI_НажатаОтключиться ИЛИ event == TRAY_Отключиться:
        ПЕРЕЙТИ В Disconnecting
        ЗАПУСТИТЬ СценарийОтключения()
      ЕСЛИ event == SYS_ПроцессЗавершён(Core, ...):
        // аварийное падение процесса
        ПЕРЕЙТИ В Disconnecting
        ЗАПУСТИТЬ СценарийОтключения() // best-effort
        ПОСЛЕ ЭТОГО ПЕРЕЙТИ В Error(ProcessFailed)

    КОГДА Disconnecting:
      // события UI игнорируются, кроме выхода
      ЕСЛИ event == UI_ВыходИзМеню ИЛИ event == TRAY_Выход:
        ПЕРЕЙТИ В Exiting
        ЗАПУСТИТЬ CleanupИВыход()

    КОГДА Error:
      ЕСЛИ event == TRAY_ПоказатьОкно:
        UI.ПоказатьГлавноеОкно()
      ЕСЛИ event == UI_ВыходИзМеню ИЛИ event == TRAY_Выход:
        ПЕРЕЙТИ В Exiting
        ЗАПУСТИТЬ CleanupИВыход()
      // Повторные попытки зависят от ErrorKind и предусловий

    КОГДА Exiting:
      // игнорировать все события
      НИЧЕГО

  КОНЕЦ
```

### 9) Спорные решения (фиксируем заранее)

1. Нажатие «Отключиться» в Connecting:

* Базовое правило на старте: игнорировать (кнопка выключена).
* Альтернатива (если понадобится): реализовать флаг отмены и на каждом шаге сценария подключения проверять "отмена" → выполнять rollback.

2. Падение процессов в Connected:

* Правило: немедленно запускать Disconnecting(best-effort cleanup) и после завершения показать Error(ProcessFailed) с деталями (какой процесс, exitCode).

3. Ошибки при отключении:

* Не блокировать возврат в ReadyDisconnected. Ошибки удаления маршрутов логируются в lastError и показываются как уведомление/диалог по желанию.

4. Конкурирующие команды из окна и трея:

* В случае одновременных/быстро последовательных команд, приоритет имеет "Выход" (TRAY_Выход / UI_ВыходИзМеню). Если команда выхода поступает во время Connecting/Disconnecting, приложение завершает текущий сценарий best-effort и переходит в Exiting (cleanup).

5. Завершение сеанса Windows / выключение системы:

* При получении сигнала завершения сессии OS приложение должно попытаться выполнить быстрый best-effort Disconnecting (остановить Core, удалить добавленные маршруты) и затем завершиться.


### 10) Детализация сценариев MVP

В данном разделе фиксируются минимально необходимое поведение для первой версии (MVP). Расширенное поведение (оффлайн-режим, отслеживание смены сети, сложный rollback и т.п.) описывается отдельно.

#### 10.1) Preflight (MVP)

Цель: убедиться, что Control-сервер доступен перед показом окна логина.

* Вход в состояние PreflightCheck происходит из AppStarting на событие UI_Запуск.
* Приложение выполняет HTTP(S)-запрос к эндпоинту `/health` Control-сервера.
* В MVP используется **один** Control-сервер, URL берётся из Config.
* При неуспехе (ошибка сети, таймаут, некорректный код ответа) выполняется до **трёх** повторных попыток с короткой задержкой между ними.
* Если все три попытки завершились неуспехом, генерируется SYS_РезультатPreflight(ошибка), выполняется переход в Error(NetworkUnavailable), в UI показывается модальный диалог "Нет связи с серверами" с кнопкой "Повторить" (запускает Preflight заново) и возможностью выхода.
* При успешной проверке (хотя бы один успешный ответ `/health`) генерируется SYS_РезультатPreflight(успех) и выполняется переход в WaitingLogin.

#### 10.2) Sync (MVP)

Цель: получить от Control-сервера список доступных прокси и профилей маршрутизации.

* Вход в состояние SyncInProgress — из AuthInProgress при успешной авторизации.
* Выполняется один запрос к Control-серверу для получения `serversList` и `routesProfiles`.
* Для MVP:
  * элементы `Server` должны содержать минимум данные для UI и подключения (например: ID/внутренний идентификатор, отображаемое имя/профиль, страна/метаданные для отображения, а также данные, достаточные для построения Core-конфигурации);
  * элементы `RouteProfile` содержат как минимум `DirectRoutes` и `TunnelRoutes` (списки IPv4-подсетей/правил), а также отображаемое имя профиля.
* Все данные, полученные в Sync, рассматриваются как единое целое:
  * если обнаружена ошибка формата/валидации **любого** элемента, вся операция Sync считается неуспешной, генерируется SYS_РезультатSync(ошибка), выполняется переход в Error(SyncFailed);
  * частично-битые данные не принимаются (клиент всегда работает только с полностью валидным набором).
* При успехе значения `serversList` и `routesProfiles` сохраняются в контекст, генерируется SYS_РезультатSync(успех), выполняется переход в PreparingEnvironment.

#### 10.3) PreparingEnvironment (MVP, Windows)

Цель: определить основной шлюз и добавить минимальные служебные маршруты.

* При входе в PreparingEnvironment выполняется поиск маршрута по умолчанию (0.0.0.0/0) в таблице маршрутизации Windows.
* В MVP предполагается, что в системе **один** маршрут по умолчанию для IPv4.
* Если обнаружено несколько маршрутов по умолчанию (несколько шлюзов) или ситуация не может быть однозначно интерпретирована, PreparingEnvironment считается неуспешным:
  * генерируется SYS_РезультатPrepareEnv(ошибка);
  * выполняется переход в Error(RoutingFailed);
  * UI показывает сообщение о невозможности определить однозначный шлюз (подозрение на уже активный VPN и т.п.), подключение запрещено до устранения проблемы.
* При успехе определяется IP-шлюза `defaultGateway` (минимум — IP-адрес). Значение сохраняется в `ctx.defaultGateway`.
* В рамках PreparingEnvironment в MVP добавляются только IPv4-служебные маршруты **до Control-сервера** через обнаруженный шлюз по умолчанию (host-маршруты). IPv6 и маршруты до прокси на этом шаге не настраиваются.
* Если добавление любого из обязательных служебных маршрутов до Control-сервера не удалось, PreparingEnvironment считается неуспешным (SYS_РезультатPrepareEnv(ошибка) → Error(RoutingFailed)).
* При полном успехе генерируется SYS_РезультатPrepareEnv(успех, defaultGateway), выполняется переход в ReadyDisconnected, показывается главное окно и загружаются списки серверов/маршрутов в UI.

#### 10.4) Connecting (MVP)

Цель: поднять туннель и маршруты в линейной последовательности с простым откатом.

Пошаговый порядок в состоянии Connecting:

1. **Добавление прямых маршрутов**:
   * добавляется host-маршрут до выбранного прокси-сервера через `defaultGateway`;
   * добавляются DirectRoutes из выбранного `RouteProfile` (IPv4-сети, идущие в обход туннеля);
   * все добавленные маршруты регистрируются в `RoutesRegistry`.
2. **Применение Core-конфигурации и запуск Core**:
   * генерируется или выбирается готовая конфигурация для Core (xray/sing-box) на основе выбранного сервера/профиля;
   * конфигурационный файл записывается на диск (при ошибке — ConfigFailed);
   * запускается процесс Core в рабочей директории приложения, путь к бинарнику берётся из Config;
   * stdout/stderr Core перенаправляются в лог приложения;
   * если запуск или раннее завершение процесса не укладывается в таймаут (по умолчанию 10 секунд) или завершается с ошибкой, сценарий считается неуспешным (ProcessFailed).
   * применяются те же базовые правила таймаута запуска (по умолчанию 10 секунд) и определения неуспешного старта.
4. **Проверка доступности через туннель**:
   * выполняется простая проверка (например, запрос к внешнему сервису "показать текущий IP") через поднятый туннель;
   * при неуспехе сценарий считается неуспешным (обычно ProcessFailed или NetworkUnavailable, в зависимости от причины).

Rollback (минимально обязательный) при ошибке на любом шаге Connecting:

* Останавливается процесс Core (если был запущен), с попыткой корректного завершения и жёстким убийством через 5 секунд при необходимости.
* Удаляются маршруты:
  * прямой маршрут до прокси;
  * DirectRoutes из выбранного профиля;
  * при этом служебные маршруты до Control-сервера, настроенные на шаге PreparingEnvironment, **сохраняются**.
* Выполняется переход в Error с соответствующим ErrorKind (RoutingFailed — при ошибках маршрутизации, ConfigFailed — при ошибках конфигурации Core, ProcessFailed — при ошибках запуска/краха процессов).

При полном успехе Connecting переходит в состояние Connected.

#### 10.5) Disconnecting (MVP)

Цель: корректно остановить процесс Core, удалить добавленные маршруты и вернуть систему в ReadyDisconnected.

Пошаговый порядок в состоянии Disconnecting:

   * ожидается до 5 секунд;
   * по истечении таймаута выполняется принудительное завершение процесса.
2. **Остановка Core**:
   * аналогично, сначала мягкий сигнал, затем принудительное завершение после ожидания до 5 секунд.
3. **Удаление маршрутов**:
   * удаляются все маршруты, связанные с туннелем и профилем маршрутизации (DirectRoutes, host-маршрут до прокси и прочие добавленные в Connecting), ориентируясь на `RoutesRegistry`;
   * служебные маршруты до Control-сервера, настроенные на шаге PreparingEnvironment, сохраняются до полного выхода из приложения (Exiting).
4. **Обработка нештатных ситуаций**:
   * если к моменту Disconnecting процесс уже завершился сам либо PID недействителен, это логируется, но не блокирует сценарий отключения;
   * любое нештатное завершение процессов фиксируется в логах, после чего всё равно выполняется полная попытка очистки маршрутов (best-effort cleanup), чтобы сохранить работоспособность интернета у пользователя.

При успешном (или best-effort) завершении шагов приложение переходит в ReadyDisconnected. Ошибки при отключении могут быть записаны в `lastError`, но не блокируют возврат в ReadyDisconnected.

#### 10.6) ErrorKind и поведение UI (MVP)

* **NetworkUnavailable**:
  * сценарии возникновения: неуспешный Preflight, потеря связи при проверках доступности;
  * UI: модальное окно с сообщением о недоступности сети/серверов и кнопками "Повторить" (перезапуск соответствующего сценария) и "Выход".
* **AuthFailed**:
  * сценарии возникновения: неверные логин/пароль, отказ в доступе, истечение токена в рамках одной сессии;
  * UI: модальное окно с сообщением об ошибке авторизации и кнопкой "Повторить" (возврат к AuthInProgress/логину).
* **SyncFailed**:
  * сценарии возникновения: ошибка запроса списков серверов/маршрутов или ошибка валидации любого элемента ответа;
  * UI: модальное окно с сообщением "Не удалось обновить списки" и кнопкой "Повторить".
* **RoutingFailed** и **ConfigFailed**:
  * в MVP используются как индикаторы внутренних ошибок подготовки маршрутизации или конфигурации Core;
  * UI: обобщённое модальное сообщение о внутренней ошибке с кнопками "ОК"/"Выход"; возможность детальной диагностики откладывается на последующие версии.
* **ProcessFailed**:
  * сценарии возникновения: падение или неуспешный старт Core;
  * UI: модальное окно с кратким описанием и кнопкой "ОК"; повторное подключение выполняется только по явному действию пользователя ("Подключиться").
* **Unknown**:
  * любые непредусмотренные ошибки;
  * UI: модальное окно с общим сообщением и кнопками "ОК"/"Выход".

ErrorInfo в MVP содержит как минимум:

* `kind: ErrorKind`;
* краткое user-friendly сообщение для UI;
* техническое сообщение/строку для логов.

#### 10.7) Auth-токен в рамках сессии (MVP)

* authToken хранится только в памяти процесса и считается действительным на время работы приложения.
* При получении от Control-сервера ответа, указывающего на проблему с авторизацией (например, HTTP 401), приложение переходит в Error(AuthFailed).
* Если в момент такой ошибки туннель был поднят (Connected), выполняется Disconnecting → ReadyDisconnected, затем переход в Error(AuthFailed). Пользователь должен авторизоваться заново до следующей попытки подключения.

#### 10.8) Трей и главное окно (MVP)

* Закрытие окна по "X" всегда означает только скрытие главного окна; приложение продолжает работать в трее.
* Команда "Выход" из трея или меню главного окна имеет приоритет над другими командами (Connect/Disconnect):
  * при получении команды выхода во время Connecting/Disconnecting выполняется best-effort завершение сценария и переход в Exiting;
  * в Exiting выполняется общий cleanup (остановка процессов, удаление всех маршрутов, включая служебные).


### 11) Отслеживание смены сети (смена маршрута по умолчанию)

Задача: если пользователь переключился на другую сеть (например, другой Wi‑Fi), то может поменяться:

* маршрут по умолчанию (default route) он же основной шлюз;
* индекс/интерфейс, через который доступен Control-сервер или прокси-сервер.

Требование: приложение должно обнаруживать такие изменения **в фоне** и корректно реагировать.

#### 11.1) Подходы

**Вариант А (предпочтительный): подписка на события Windows**

* Подписаться на изменения IP-интерфейсов (NotifyIpInterfaceChange).
* Подписаться на изменения таблицы маршрутизации (NotifyRouteChange2).

Плюсы:

* реагирует быстро;
* не расходует ресурсы на постоянный опрос.

Минусы:

* требуется аккуратная реализация через WinAPI (cgo или golang.org/x/sys/windows).

**Вариант Б (резервный): периодическая проверка**

* Раз в N секунд вычислять текущий default gateway и сравнивать с сохранённым.

Плюсы:

* простая реализация.

Минусы:

* реакция с задержкой;
* лишняя нагрузка (хотя небольшая).

Решение для первой версии Windows:

* реализовать вариант А, и держать вариант Б как fallback (включать автоматически при ошибке подписки).

#### 11.2) Что считается "сменой сети"

Смена сети фиксируется, если изменилось хотя бы одно:

* defaultGateway (IP шлюза) или интерфейс (InterfaceIndex/InterfaceLuid), к которому привязан маршрут 0.0.0.0/0;
* набор активных интерфейсов (up/down), влияющий на маршрут по умолчанию.

#### 11.3) Реакция приложения на смену сети

Общие правила:

1. Событие "Сеть изменилась" должно ставиться в очередь обработки и **дедуплицироваться** (часто приходит пачка событий).
2. Реакция зависит от текущего состояния приложения.

Реакции по состояниям:

* Если state ∈ {PreflightCheck, WaitingLogin, AuthInProgress, SyncInProgress, PreparingEnvironment}:

  * обновить defaultGateway;
  * переоценить служебные маршруты; при необходимости переустановить.

* Если state == ReadyDisconnected:

  * пересчитать defaultGateway;
  * переустановить служебные маршруты до Control-сервера и всех известных прокси-серверов (best-effort);
  * обновить индикатор состояния сети в UI (если есть).

* Если state == Connecting:

  * Остановить подключение, т.к. нужно выполнить переподключение и переустановку маршрутов. Потому что с вероятностью 99% коннект пропадёт и ничего не будет работать.

* Если state == Connected:

  * цель: сохранить работоспособность.
  * выполнить:

    1. пересчёт defaultGateway;
    2. переустановка служебных маршрутов (чтобы core/tun могли продолжать достукиваться до Control/Proxy);
    3. если после обновления связь всё равно потеряна (определяется отдельной проверкой доступности), выполнить аварийное отключение: переход в Disconnecting → ReadyDisconnected → Error(NetworkUnavailable).

#### 11.4) Дедупликация событий смены сети

Рекомендуемая схема:

* при первом событии ставим таймер "окно стабилизации" (например, 2 секунды);
* пока таймер не истёк, новые события игнорируются;
* по истечении таймера выполняем один пересчёт gateway/маршрутов.

#### 11.5) Псевдокод: монитор сети (универсальная логика)

```text
ПРОЦЕДУРА ЗапуститьМониторСети():
    попытка = ПодписатьсяНаСобытияWindows()
    ЕСЛИ попытка == УСПЕХ:
        режим = "СОБЫТИЯ"
    ИНАЧЕ:
        режим = "ОПРОС"
        каждые N секунд ВЫЗВАТЬ ПроверитьСменуСети()

ПРОЦЕДУРА OnWindowsNetworkEvent():
    ЕСЛИ debounceTimer активен:
        ВЫХОД
    ИНАЧЕ:
        запустить debounceTimer на 2 секунды
    ПО ИСТЕЧЕНИИ:
        ВЫЗВАТЬ ПроверитьСменуСети()

ПРОЦЕДУРА ПроверитьСменуСети():
    новыйGateway = ОпределитьDefaultGateway()
    ЕСЛИ новыйGateway != ctx.defaultGateway:
        ctx.defaultGateway = новыйGateway
        ПОСЛАТЬ СОБЫТИЕ SYS_СетьИзменилась(новыйGateway)

СОБЫТИЕ SYS_СетьИзменилась(newGateway) обрабатывается в главном state machine:
    ВЫЗВАТЬ РеакцияНаСменуСетиПоСостоянию(state)
```

#### 11.6) Псевдокод: реакция на смену сети

```text
ПРОЦЕДУРА РеакцияНаСменуСетиПоСостоянию(state):
    ЛОГ "Сеть изменилась, новый шлюз=..."

    ЕСЛИ state В {ReadyDisconnected}:
        ВЫЗВАТЬ ОбновитьСлужебныеМаршруты()

    ЕСЛИ state В {Connected}:
        ВЫЗВАТЬ ОбновитьСлужебныеМаршруты()
        ЕСЛИ ПроверкаДоступностиПроксиИлиControl() == ОШИБКА:
        ПЕРЕЙТИ В Disconnecting
        ЗАПУСТИТЬ СценарийОтключения()
        ПЕРЕЙТИ В Error(NetworkUnavailable)

    ИНАЧЕ:
        // Для остальных состояний — только обновить gateway и служебные маршруты best-effort
        ВЫЗВАТЬ ОбновитьСлужебныеМаршруты() (best-effort)
```

#### 11.7) Примечания по Windows API (источник истины)

* Для событий маршрутов: NotifyRouteChange2.
* Для событий изменения IP-интерфейсов: NotifyIpInterfaceChange.

Эти функции определены как механизм подписки на изменения и предназначены для долгоживущих уведомлений.
